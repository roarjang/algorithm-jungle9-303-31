# 문제: https://www.acmicpc.net/problem/1904
# 날짜: 2025-06-07
# 난이도: SILVER III
# 문제유형: DP + 모듈러

# 문제 핵심
# 길이 N인 모든 이진 수열 중에서,
# '1' 또는 '00'으로만 이루어진 수열의 경우의 수를 구하는 문제이다.
# 예: N = 4일 때 가능한 조합: 1111, 1100, 1001, 0011, 0000 등

# 가능한 타일 구성은 다음과 같다.
#   - 1칸을 채우는 타일: '1'
#   - 2칸을 채우는 타일: '00'
# 즉, N칸을 채우는 방법은 다음 두 가지 상황을 고려하면 된다.
#   - 마지막에 '1'을 붙인 경우: f(N - 1)
#   - n = 4 -> [111] + '1', [100] + '1', [001] + '1' -> 총 f(3)개의 수열에 '1'을 붙인 것
#   - 마지막에 '00'을 붙인 경우: f(N - 2)
#   - n = 4 -> [11] + '00', [00] + '00' -> 총 f(2)개의 수열에 '00'을 붙인 것

# 따라서 점화식은
# f(N) = f(N - 1) + f(N - 2)

# 이는 피보나치 수열과 유사한 형태의 점화식이다.

# DP를 사용하는 이유
# 같은 서브문제가 반복되므로, 메모이제이션 또는 반복문을 활용해 중복 연산을 줄일 수 있다.

# 모듈러(15746)를 사용하는 이유
# 결과 수가 매우 커질 수 있으므로, 중간 중간마다 15746으로 나눠서 수를 작게 유지한다.

# 입력
# 자연수 N이 주어진다. (1 <= N <= 1,000,000)

# 출력
# N길이의 이진 수열 중, '1' 또는 '00'으로만 구성된 모든 가능한 조합의 수를
# 15746으로 나눈 나머지를 출력한다.

# 시간복잡도: O(N)
# -> 반복문을 통해 f(2)부터 f(N)까지 순차적으로 계산

# 공간복잡도: O(1)
# -> 변수 2개만 사용해 이전 결과만 저장 (공간 최적화)

from sys import stdin
stdin = open('input.txt', 'r')
input = lambda: stdin.readline().strip()

def count_case(N):
    if N == 1: return 1
    elif N == 2: return 2

    prev2, prev1 = 1, 2 # f(1), f(2)

    for _ in range(3, N + 1):
        prev2, prev1 = prev1, (prev2 + prev1) % 15746
    
    return prev1

N = int(input())

print(count_case(N))